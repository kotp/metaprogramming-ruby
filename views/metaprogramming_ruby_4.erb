<div>
<h1>Metaprogramming in Ruby</h1>

<h2>1.6 Solved Problems</h2>
<h3>1.6.1 Problem 1  <img src="http://rubylearning.com/images/icon-flag.gif" alt="Important" title="Important" /></h3>
<p>We all know that the Core Ruby course at RubyLearning.org runs for 8 weeks. Every week there is a quiz and marks are allocated out of 10. At the end of 8 weeks the student can find out his percentage score. For example, if a students scores 5,10,10,10,10,10,10,10 marks in 8 weeks i.e. his percentage score is 93.75%</p>
<p><b>Problem Statement</b>: Every Core Ruby batch has hundreds of students. Let us assume that we have a Ruby method that does this percentage calculation and returns the same value given the same set of arguments. We don't need to go on calculating the value each time. We only need to calculate the value the first time and then somehow associate that value with that set of arguments. Then the next time it gets called, if we have the same arguments, we can use the previously stored value as the return value of this method thus bypassing the need to do the calculations again.</p>

<h4>1.6.1.1 Normal Solution</h4>
<p>To start with, let us look at an existing class and method and then keep modifying them to achieve the above result.</p>
<pre>
class Result
  def total(*scores)
    percentage_calculation(*scores)
  end
  
  private
  
  def percentage_calculation(*scores)
    puts "Calculation for #{scores.inspect}"
    scores.inject {|sum, n| sum + n } * (100.0/80.0)
  end
end

r = Result.new
puts r.total(5,10,10,10,10,10,10,10)
puts r.total(5,10,10,10,10,10,10,10)
puts r.total(10,10,10,10,10,10,10,10)
puts r.total(10,10,10,10,10,10,10,10)
</pre>
<p>In the code above, we have a <b>Result</b> class and a <b>total</b> method that takes a list of <b>scores</b> per student. The <b>scores</b> represent the marks obtained by a student in each of the 8 quizzes in the course. The private method <b>percentage_calculation</b> does the actual percentage calculation. To test this, we call the <b>total</b> method 4 times. The first two and the last two have the same set of scores. When we run our code we get the following output:</p>
<pre>
Calculation for [5, 10, 10, 10, 10, 10, 10, 10]
93.75
Calculation for [5, 10, 10, 10, 10, 10, 10, 10]
93.75
Calculation for [10, 10, 10, 10, 10, 10, 10, 10]
100.0
Calculation for [10, 10, 10, 10, 10, 10, 10, 10]
100.0
</pre>
<p>Looking at the above output, we realize that we have called the <b>total</b> method 4 times and that in turn also called the <b>percentage_calculation</b> method 4 times. <span style="color:brown;">We are now going to try and reduce the number of calls to the <b>percentage_calculation</b> method</span>.</p>
<p>One way to reduce the number of calls to the <b>percentage_calculation</b> method is to somehow store the previous results in memory. For this, we shall define a subclass named <b>MemoResult</b> that has a hash named <b>@mem</b> and then use the <b>@mem</b> hash in the <b>total</b> method, as shown in the modified code below:</p>
<pre>
class Result
  def total(*scores)
    percentage_calculation(*scores)
  end
  
  private
  
  def percentage_calculation(*scores)
    puts "Calculation for #{scores.inspect}"
    scores.inject {|sum, n| sum + n } * (100.0/80.0)
  end
end

class MemoResult &lt; Result
  def initialize
    @mem = {}
  end
  def total(*scores)
    if @mem.has_key?(scores)
      @mem[scores]
    else
      @mem[scores] = super
    end
  end
end

r = MemoResult.new
puts r.total(5,10,10,10,10,10,10,10)
puts r.total(5,10,10,10,10,10,10,10)
puts r.total(10,10,10,10,10,10,10,10)
puts r.total(10,10,10,10,10,10,10,10)
</pre>

<p>The <b>Hash</b> class has a <b>has_key?</b> method that returns <b>true</b> if the given key is present in <b>@mem</b>. In the above program, if <b>has_key?</b> is <b>true</b> then we return the value available in <b>@mem</b> for that key otherwise we do the calculation by calling <b>percentage_calculation(*scores)</b> and storing the value in <b>@mem</b>. Let us see the output:</p>
<pre>
Calculation for [5, 10, 10, 10, 10, 10, 10, 10]
93.75
93.75
Calculation for [10, 10, 10, 10, 10, 10, 10, 10]
100.0
100.0
</pre>
<p>Observe that we have saved calling the <b>percentage_calculation(*scores)</b> method for the second and fourth call to <b>r.total</b>.</p>

<h4>1.6.1.2 Solution using Class.new and define_method</h4>
<p>The <b>MemoResult</b> class is intimately tied to its parent <b>Result</b> class. To avoid that, let us generate this subclass dynamically using whetever we have learnt so far in <strong>Ruby Metaprogramming</strong>.</p>

<p>To do that, let us write a method called <b>mem_result</b> that takes two parameters: the name of the parent class and the name of a method (the method will return the name of the class). Here's the code:</p>
<pre>
class Result
  def total(*scores)
    percentage_calculation(*scores)
  end
  
  private
  
  def percentage_calculation(*scores)
    puts "Calculation for #{scores.inspect}"
    scores.inject {|sum, n| sum + n } * (100.0/80.0)
  end
end

def mem_result(klass, method)
  mem = {}
  Class.new(klass) do
    define_method(method) do |*args|
      if mem.has_key?(args)
        mem[args]
      else
        mem[args] = super
      end
    end
  end
end

r = mem_result(Result, :total).new
puts r.total(5,10,10,10,10,10,10,10)
puts r.total(5,10,10,10,10,10,10,10)
puts r.total(10,10,10,10,10,10,10,10)
puts r.total(10,10,10,10,10,10,10,10)
</pre>
<p>The output is:</p>
<pre>
Calculation for [5, 10, 10, 10, 10, 10, 10, 10]
93.75
93.75
Calculation for [10, 10, 10, 10, 10, 10, 10, 10]
100.0
100.0
</pre>
<p>The code <b>Class.new(klass)</b> creates a new anonymous class with the given superclass <b>klass</b>. The block is used as the body of the class and contains the methods in that class. The <b>define_method</b> defines the method <b>method</b> (which is the second argument to <b>mem_result</b>). This takes the <b>method</b> arguments in <b>args</b>.</p>
<p><b>Note</b>: We have done away with the <b>initialize</b> method and the instance variable <b>@mem</b>. Instead we use a local variable <b>mem</b> since the block is a closure and this local variable <b>mem</b> is available inside the block.</p>

<p class="pre-footer align-right">
  <b>
    <a href="http://metaprogramming-ruby.heroku.com/">&lt;Home | </a>
    <a href="http://metaprogramming-ruby.heroku.com/metaprogramming_ruby_3">Prev | </a>        
    <a href="http://metaprogramming-ruby.heroku.com/metaprogramming_ruby_5">Next&gt;</a>
  </b>
</p>

<p class="copyright"><b>Note</b>: The Ruby Logo is Copyright (c) 2006, Yukihiro Matsumoto. The material in these study notes is drawn primarily from the references mentioned on the last page. Our acknowledgment and thanks to all of them.</p>
</div>
<!-- Hit Tail (Invisible code) -->
<script src="http://13043.hittail.com/mlt.js" type="text/javascript"></script>
<!-- Hit Tail (Invisible code) -->

<!-- Google Analytics code -->
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-59044-10");
pageTracker._trackPageview();
</script>
<!-- Google Analytics code ends -->
